-- VHDL Entity ece411.Cache_Datapath.interface
--
-- Created:
--          by - adalton2.ews (gelib-057-05.ews.illinois.edu)
--          at - 20:45:54 02/20/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Cache_Datapath IS
   PORT( 
      ADDRESS     : IN     LC3b_word;
      AddrSel     : IN     std_logic;
      CLK         : IN     STD_LOGIC;
      DATAOUT     : IN     LC3b_word;
      LD_Cache    : IN     std_logic;
      MREAD_L     : IN     std_logic;
      MRESPSel    : IN     std_logic;
      MWRITEH_L   : IN     std_logic;
      MWRITEL_L   : IN     std_logic;
      PMDATAIN    : IN     LC3B_OWORD;
      RESET_L     : IN     STD_LOGIC;
      cont_RESP_H : IN     std_logic;
      DATAIN      : OUT    LC3b_word;
      MRESP_H     : OUT    std_logic;
      PMADDRESS   : OUT    LC3B_WORD;
      PMDATAOUT   : OUT    LC3B_OWORD;
      WayMuxDirty : OUT    std_logic;
      hit         : OUT    std_logic;
      read        : OUT    std_logic;
      write       : OUT    std_logic
   );

-- Declarations

END Cache_Datapath ;

--
-- VHDL Architecture ece411.Cache_Datapath.struct
--
-- Created:
--          by - adalton2.ews (gelib-057-05.ews.illinois.edu)
--          at - 20:45:54 02/20/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;


ARCHITECTURE struct OF Cache_Datapath IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL B            : std_logic;
   SIGNAL B1           : std_logic;
   SIGNAL DataOut0     : LC3b_oword;
   SIGNAL DataOut1     : LC3b_oword;
   SIGNAL DirtyOut0    : std_logic;
   SIGNAL DirtyOut1    : std_logic;
   SIGNAL INDEX        : LC3B_C_INDEX;
   SIGNAL LRUIn        : STD_LOGIC;
   SIGNAL LRUOut       : std_logic;
   SIGNAL OFFSET       : LC3B_C_OFFSET;
   SIGNAL ReadAndHit   : std_logic;
   SIGNAL TAG          : LC3B_C_TAG;
   SIGNAL TagAND0      : std_logic;
   SIGNAL TagAND1      : std_logic;
   SIGNAL TagOut0      : LC3B_C_TAG;
   SIGNAL TagOut1      : LC3B_C_TAG;
   SIGNAL TagisEqual0  : std_logic;
   SIGNAL TagisEqual1  : std_logic;
   SIGNAL ValidOut0    : std_logic;
   SIGNAL ValidOut1    : std_logic;
   SIGNAL Way0Write    : STD_LOGIC;
   SIGNAL Way1Write    : STD_LOGIC;
   SIGNAL WayMuxData   : LC3b_oword;
   SIGNAL WayMuxTag    : LC3B_C_TAG;
   SIGNAL WayMuxValid  : std_logic;
   SIGNAL WriteAddress : LC3b_word;

   -- Implicit buffer signal declarations
   SIGNAL MRESP_H_internal : std_logic;
   SIGNAL hit_internal     : std_logic;
   SIGNAL read_internal    : std_logic;
   SIGNAL write_internal   : std_logic;


   -- Component Declarations
   COMPONENT AND2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT AddressJoin
   PORT (
      INDEX        : IN     LC3B_C_INDEX ;
      WayMuxTag    : IN     LC3B_C_TAG ;
      WriteAddress : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT AddressSplit
   PORT (
      ADDRESS : IN     LC3b_word ;
      OFFSET  : OUT    LC3B_C_OFFSET ;
      INDEX   : OUT    LC3B_C_INDEX ;
      TAG     : OUT    LC3B_C_TAG 
   );
   END COMPONENT;
   COMPONENT BitMux2
   PORT (
      A   : IN     std_logic ;
      B   : IN     std_logic ;
      Sel : IN     std_logic ;
      C   : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT Data16Mux
   PORT (
      OFFSET     : IN     LC3B_C_OFFSET ;
      DATAIN     : OUT    LC3b_word ;
      WayMuxData : IN     LC3b_oword 
   );
   END COMPONENT;
   COMPONENT LRUArray
   PORT (
      Index    : IN     LC3b_c_index;
      LRUIn    : IN     std_logic;
      LRUWrite : IN     std_logic;
      RESET_L  : IN     std_logic;
      LRUOut   : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT LRUDecode
   PORT (
      LRUOut    : IN     std_logic ;
      Way0Write : OUT    STD_LOGIC ;
      Way1Write : OUT    STD_LOGIC ;
      LD_Cache  : IN     std_logic ;
      LRUIn     : OUT    STD_LOGIC ;
      TagAND0   : IN     std_logic ;
      TagAND1   : IN     std_logic 
   );
   END COMPONENT;
   COMPONENT NOT1
   PORT (
      A : IN     std_logic ;
      B : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT OR2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT TagCompare
   PORT (
      TagA    : IN     LC3B_C_TAG;
      TagB    : IN     LC3B_C_TAG;
      isEqual : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT WayMux
   PORT (
      DataOut0    : IN     LC3b_oword ;
      DataOut1    : IN     LC3b_oword ;
      DirtyOut0   : IN     std_logic ;
      DirtyOut1   : IN     std_logic ;
      TagAND0     : IN     std_logic ;
      TagAND1     : IN     std_logic ;
      TagOut0     : IN     LC3B_C_TAG ;
      TagOut1     : IN     LC3B_C_TAG ;
      ValidOut0   : IN     std_logic ;
      ValidOut1   : IN     std_logic ;
      WayMuxData  : OUT    LC3b_oword ;
      WayMuxDirty : OUT    std_logic ;
      WayMuxTag   : OUT    LC3B_C_TAG ;
      WayMuxValid : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT WordMux2
   PORT (
      A   : IN     LC3b_word ;
      B   : IN     LC3b_word ;
      Sel : IN     std_logic ;
      F   : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT way
   PORT (
      CacheWrite : IN     std_logic ;
      DataIn     : IN     LC3b_oword ;
      DirtyIn    : IN     std_logic ;
      Index      : IN     LC3b_c_index ;
      RESET_L    : IN     std_logic ;
      TagIn      : IN     LC3B_C_TAG ;
      DataOut    : OUT    LC3b_oword ;
      DirtyOut   : OUT    std_logic ;
      TagOut     : OUT    LC3B_C_TAG ;
      ValidOut   : OUT    std_logic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : AND2 USE ENTITY ece411.AND2;
   FOR ALL : AddressJoin USE ENTITY ece411.AddressJoin;
   FOR ALL : AddressSplit USE ENTITY ece411.AddressSplit;
   FOR ALL : BitMux2 USE ENTITY ece411.BitMux2;
   FOR ALL : Data16Mux USE ENTITY ece411.Data16Mux;
   FOR ALL : LRUArray USE ENTITY ece411.LRUArray;
   FOR ALL : LRUDecode USE ENTITY ece411.LRUDecode;
   FOR ALL : NOT1 USE ENTITY ece411.NOT1;
   FOR ALL : OR2 USE ENTITY ece411.OR2;
   FOR ALL : TagCompare USE ENTITY ece411.TagCompare;
   FOR ALL : WayMux USE ENTITY ece411.WayMux;
   FOR ALL : WordMux2 USE ENTITY ece411.WordMux2;
   FOR ALL : way USE ENTITY ece411.way;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   Tag1AND : AND2
      PORT MAP (
         A => TagisEqual0,
         B => ValidOut0,
         C => TagAND0
      );
   Tag2AND : AND2
      PORT MAP (
         A => TagisEqual1,
         B => ValidOut1,
         C => TagAND1
      );
   U_0 : AND2
      PORT MAP (
         A => read_internal,
         B => hit_internal,
         C => ReadAndHit
      );
   aAddressJoin : AddressJoin
      PORT MAP (
         INDEX        => INDEX,
         WayMuxTag    => WayMuxTag,
         WriteAddress => WriteAddress
      );
   aAddressSplit : AddressSplit
      PORT MAP (
         ADDRESS => ADDRESS,
         OFFSET  => OFFSET,
         INDEX   => INDEX,
         TAG     => TAG
      );
   MRESP_MUX : BitMux2
      PORT MAP (
         A   => cont_RESP_H,
         B   => ReadAndHit,
         Sel => MRESPSel,
         C   => MRESP_H_internal
      );
   aData16Mux : Data16Mux
      PORT MAP (
         OFFSET     => OFFSET,
         DATAIN     => DATAIN,
         WayMuxData => WayMuxData
      );
   aLRUArray : LRUArray
      PORT MAP (
         RESET_L  => RESET_L,
         LRUWrite => MRESP_H_internal,
         Index    => INDEX,
         LRUIn    => LRUIn,
         LRUOut   => LRUOut
      );
   aLRUDecode : LRUDecode
      PORT MAP (
         LRUOut    => LRUOut,
         Way0Write => Way0Write,
         Way1Write => Way1Write,
         LD_Cache  => LD_Cache,
         LRUIn     => LRUIn,
         TagAND0   => TagAND0,
         TagAND1   => TagAND1
      );
   U_1 : NOT1
      PORT MAP (
         A => MWRITEH_L,
         B => B
      );
   U_2 : NOT1
      PORT MAP (
         A => MWRITEL_L,
         B => B1
      );
   U_3 : NOT1
      PORT MAP (
         A => MREAD_L,
         B => read_internal
      );
   TagOR : OR2
      PORT MAP (
         A => TagAND0,
         B => TagAND1,
         C => hit_internal
      );
   U_4 : OR2
      PORT MAP (
         A => B,
         B => B1,
         C => write_internal
      );
   Tag1Compare : TagCompare
      PORT MAP (
         TagA    => TAG,
         TagB    => TagOut0,
         isEqual => TagisEqual0
      );
   Tag2Compare : TagCompare
      PORT MAP (
         TagA    => TAG,
         TagB    => TagOut1,
         isEqual => TagisEqual1
      );
   aWayMux : WayMux
      PORT MAP (
         DataOut0    => DataOut0,
         DataOut1    => DataOut1,
         DirtyOut0   => DirtyOut0,
         DirtyOut1   => DirtyOut1,
         TagAND0     => TagAND0,
         TagAND1     => TagAND1,
         TagOut0     => TagOut0,
         TagOut1     => TagOut1,
         ValidOut0   => ValidOut0,
         ValidOut1   => ValidOut1,
         WayMuxData  => WayMuxData,
         WayMuxDirty => WayMuxDirty,
         WayMuxTag   => WayMuxTag,
         WayMuxValid => WayMuxValid
      );
   AddressMux : WordMux2
      PORT MAP (
         A   => ADDRESS,
         B   => WriteAddress,
         Sel => AddrSel,
         F   => PMADDRESS
      );
   Way0 : way
      PORT MAP (
         CacheWrite => Way0Write,
         DataIn     => PMDATAIN,
         DirtyIn    => write_internal,
         Index      => INDEX,
         RESET_L    => RESET_L,
         TagIn      => TAG,
         DataOut    => DataOut0,
         DirtyOut   => DirtyOut0,
         TagOut     => TagOut0,
         ValidOut   => ValidOut0
      );
   Way1 : way
      PORT MAP (
         CacheWrite => Way1Write,
         DataIn     => PMDATAIN,
         DirtyIn    => write_internal,
         Index      => INDEX,
         RESET_L    => RESET_L,
         TagIn      => TAG,
         DataOut    => DataOut1,
         DirtyOut   => DirtyOut1,
         TagOut     => TagOut1,
         ValidOut   => ValidOut1
      );

   -- Implicit buffered output assignments
   MRESP_H <= MRESP_H_internal;
   hit     <= hit_internal;
   read    <= read_internal;
   write   <= write_internal;

END struct;
